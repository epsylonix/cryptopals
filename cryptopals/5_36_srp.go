package cryptopals

import (
	"bytes"
	"math/big"
)

/*
The essense of the SRP:
1. Client sends Server his/her username, (e.g. Client).
2. Server looks up Client's password entry and
fetches the password verifier v and the salt s.
He sends s to Client. Client computes long-
term private key x using s and her real password P.
3. Client generates a random number a, 1 < a < n,
public key A = g ^a and sends it to Server.
4. Server generates his random number b, 1 < b < n,
public key B = v * k + g ^ b, and sends it to Client,
along with the randomly generated parameter u.
5. Client and Server compute the common value
S = g ^ (b*a + b*u*x)

for Client:
  g ^ b = B - v * k = B - (g^x) * k
	S = g ^ (b * (a+ u*x)) = (g ^ b) ^ (a + u * x)

for Server:
	S = (g ^ (a + ux))^b = ((g ^ a) * ((g ^ x) ^ u)) ^ b = (A * (v ^ u)) ^ b
*/

// client =======================

type srpClient struct {
	username []byte
	password []byte
	g        *big.Int
	n        *big.Int
}

func (sc *srpClient) genVerifier() ([]byte, *big.Int) {
	// v = g ^ H(salt | password) % n

	// salt should be generated by the server
	// but it is generated here for simplicity
	salt := randomBigInt(16).Bytes()
	xB := sha1(append(salt, sc.password...))
	x := new(big.Int).SetBytes(xB[:])
	verifier := expMod(sc.g, x, sc.n)

	return salt, verifier
}

// client session =======================

type srpClientSession struct {
	sc       *srpClient
	x        *big.Int
	private  *big.Int
	public   *big.Int
	session  []byte
	salt     []byte
	loginKey []byte
}

func (scs *srpClientSession) k() *big.Int {
	return big.NewInt(int64(3))
}

func (scs *srpClientSession) init(salt []byte) *srpClientSession {
	// salt is stored on the server
	xB := sha1(append(salt, scs.sc.password...))
	scs.x = new(big.Int).SetBytes(xB[:])

	scs.private = randomBigIntLessThan(scs.sc.n)
	scs.public = expMod(scs.sc.g, scs.private, scs.sc.n)
	scs.salt = append(salt[:0:0], salt...)
	return scs
}

func (scs *srpClientSession) genSessionKey(b *big.Int, u *big.Int) *srpClientSession {
	// server send B = v * k + g^b
	// client can calculate v = g ^ x = g ^ H(salt|password)
	v := expMod(scs.sc.g, scs.x, scs.sc.n)
	vk := mulMod(v, scs.k(), scs.sc.n)
	// S = (g ^ b)^(a + u * x) = (B - v * k) ^(a + u * x)
	gExpB := subMod(b, vk, scs.sc.n)
	aAddUX := new(big.Int).Mul(u, scs.x)
	aAddUX = aAddUX.Add(scs.private, aAddUX)

	s := expMod(gExpB, aAddUX, scs.sc.n)
	tmp := sha1(s.Bytes())
	scs.session = tmp[:]

	tmp = sha1Hmac(scs.session, scs.salt)
	scs.loginKey = tmp[:]

	return scs
}

// server =======================

type srpServer struct {
	username []byte
	salt     []byte
	verifier *big.Int
	g        *big.Int
	n        *big.Int
}

// server session =======================

type srpServerSession struct {
	ss      *srpServer
	u       *big.Int
	private *big.Int
	public  *big.Int
	session []byte
}

func (sss *srpServerSession) k() *big.Int {
	return big.NewInt(int64(3))
}

func (sss *srpServerSession) init() *srpServerSession {
	sss.u = randomBigInt(4)
	sss.private = randomBigIntLessThan(sss.ss.n)

	gExpB := expMod(sss.ss.g, sss.private, sss.ss.n)
	vk := mulMod(sss.ss.verifier, sss.k(), sss.ss.n)
	// B = v * k + g^b
	sss.public = addMod(vk, gExpB, sss.ss.n)
	return sss
}

func (sss *srpServerSession) genSessionKey(a *big.Int) *srpServerSession {
	// S = (A * (v ^ u)) ^ b
	vExpU := expMod(sss.ss.verifier, sss.u, sss.ss.n)

	s := expMod(mulMod(vExpU, a, sss.ss.n), sss.private, sss.ss.n)
	tmp := sha1(s.Bytes())
	sss.session = tmp[:]

	return sss
}

func (sss *srpServerSession) login(clientGeneratedKey []byte) bool {
	loginKey := sha1Hmac(sss.session, sss.ss.salt)
	return bytes.Equal(clientGeneratedKey, loginKey[:])
}
